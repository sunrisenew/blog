import{_ as a,o as s,c as e,f as t,e as n}from"./app-CFR8qRQT.js";const o={},c=n("<p>日常开发中我们经常会遇到这样一种情况：有两个实体<code>图书Book</code>和<code>文件File</code>是多对多的关系，但是一般我们只关心与图书关联了多少文件而不关心文件关联了多少图书。所以通常我们在<code>Book</code>中用一个属性<code>file_ids</code>以<code>逗号分割</code>的方式存储多个<code>File</code>的id。</p><p>但是<code>File</code>的id是一个<code>Long</code>类型的<code>自增主键</code>，我们将<code>Book</code>对象查询出来后还要再对<code>file_ids</code>属性进行分割处理，处理完保存时又要进行逗号拼接，非常麻烦。有没有一个办法可以将这个繁琐的操作简化呢？<code>JPA</code>有一个注解<code>@javax.persistence.Convert</code>可以帮我们做这件事。</p>",2),p=n(`<h2 id="使用-convert注解自动转换实体中的属性" tabindex="-1"><a class="header-anchor" href="#使用-convert注解自动转换实体中的属性"><span>使用<code>@Convert</code>注解自动转换实体中的属性</span></a></h2><p>先上代码：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">cn<span class="token punctuation">.</span>sunrisenew<span class="token punctuation">.</span>bms<span class="token punctuation">.</span>converter<span class="token punctuation">.</span></span><span class="token class-name">CommaDelimitedValueConverter</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@Entity</span>
<span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;book&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;file_ids&quot;</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Convert</span><span class="token punctuation">(</span>converter <span class="token operator">=</span> <span class="token class-name">CommaDelimitedValueConverter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fileIds<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在我们定义的<code>Book</code>实体类中，属性<code>fileIds</code>上加了一个注解<code>@Convert(converter = CommaDelimitedValueConverter.class)</code>，其中参数<code>converter</code>传入的类，便是<code>JPA</code>帮我们做属性值转换时使用的转换器类。这个转换器类不是随便传一个类都可以，而是需要符合一定的规范。<code>符合规范</code>这个概念在Java的世界中，一般是实现接口或者继承抽象类。</p><h2 id="创建自定义转换器来转换逗号分割值" tabindex="-1"><a class="header-anchor" href="#创建自定义转换器来转换逗号分割值"><span>创建自定义转换器来转换逗号分割值</span></a></h2><p>要想创建我们的自定义转换器，先要实现接口<code>javax.persistence.AttributeConverter</code>。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AttributeConverter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">X</span><span class="token punctuation">,</span><span class="token class-name">Y</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">Y</span> <span class="token function">convertToDatabaseColumn</span><span class="token punctuation">(</span><span class="token class-name">X</span> attribute<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">X</span> <span class="token function">convertToEntityAttribute</span><span class="token punctuation">(</span><span class="token class-name">Y</span> dbData<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据该接口的定义我们可以知道：</p><ul><li>该接口是一个泛型接口，有<code>&lt;X, Y&gt;</code>两个泛型。</li><li>接口中有两个方法，顾名思义： <ul><li>方法<code>convertToDatabaseColumn</code>是在实体对象保存到数据库时，将<code>X</code>类型的<code>属性值</code>转换为<code>Y</code>类型的<code>数据库列值</code>。</li><li>方法<code>convertToEntityAttribute</code>是在读取数据库创建实体对象时，将<code>Y</code>类型的<code>数据库列值</code>转换为<code>X</code>类型的<code>属性值</code>。</li></ul></li></ul><p>搞清楚接口的定义之后，我们就可以来实现一个自定义转换器了。下面的代码创建了一个逗号分割值转换器，实现了接口的泛型<code>&lt;Long[], String&gt;</code>。借助于<code>Spring</code>为我们提供的<code>StringUtils</code>，我们用简洁且<code>空安全</code>的代码来处理<code>Long</code>数组和逗号分割字符串之间的转换。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>sunrisenew<span class="token punctuation">.</span>converter</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">StringUtils</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span></span><span class="token class-name">AttributeConverter</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommaDelimitedValueConverter</span> <span class="token keyword">implements</span> <span class="token class-name">AttributeConverter</span><span class="token operator">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">convertToDatabaseColumn</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> longs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">arrayToCommaDelimitedString</span><span class="token punctuation">(</span>longs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">convertToEntityAttribute</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token operator">::</span><span class="token function">valueOf</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了这个转换器，以后处理数据库中的逗号分隔值就更方便啦。</p>`,12);function i(l,d){return s(),e("div",null,[c,t(" more "),p])}const r=a(o,[["render",i],["__file","annotation-convert-in-jpa.html.vue"]]),k=JSON.parse('{"path":"/java/jpa/annotation-convert-in-jpa.html","title":"JPA注解@Convert","lang":"zh-CN","frontmatter":{"title":"JPA注解@Convert","tags":["Java","JPA","SpringBoot"],"description":"日常开发中我们经常会遇到这样一种情况：有两个实体图书Book和文件File是多对多的关系，但是一般我们只关心与图书关联了多少文件而不关心文件关联了多少图书。所以通常我们在Book中用一个属性file_ids以逗号分割的方式存储多个File的id。 但是File的id是一个Long类型的自增主键，我们将Book对象查询出来后还要再对file_ids属性进...","head":[["meta",{"property":"og:url","content":"https://blog.sunrisenew.cn/java/jpa/annotation-convert-in-jpa.html"}],["meta",{"property":"og:site_name","content":"sunrisenew"}],["meta",{"property":"og:title","content":"JPA注解@Convert"}],["meta",{"property":"og:description","content":"日常开发中我们经常会遇到这样一种情况：有两个实体图书Book和文件File是多对多的关系，但是一般我们只关心与图书关联了多少文件而不关心文件关联了多少图书。所以通常我们在Book中用一个属性file_ids以逗号分割的方式存储多个File的id。 但是File的id是一个Long类型的自增主键，我们将Book对象查询出来后还要再对file_ids属性进..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-26T12:07:12.000Z"}],["meta",{"property":"article:author","content":"sunrisenew"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JPA"}],["meta",{"property":"article:tag","content":"SpringBoot"}],["meta",{"property":"article:modified_time","content":"2024-03-26T12:07:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JPA注解@Convert\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-26T12:07:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"sunrisenew\\",\\"url\\":\\"https://blog.sunrisenew.cn\\",\\"email\\":\\"sunrisenew@foxmail.com\\"}]}"]]},"headers":[{"level":2,"title":"使用@Convert注解自动转换实体中的属性","slug":"使用-convert注解自动转换实体中的属性","link":"#使用-convert注解自动转换实体中的属性","children":[]},{"level":2,"title":"创建自定义转换器来转换逗号分割值","slug":"创建自定义转换器来转换逗号分割值","link":"#创建自定义转换器来转换逗号分割值","children":[]}],"git":{"createdTime":1710050425000,"updatedTime":1711454832000,"contributors":[{"name":"sunrisenew","email":"sunrisenew@foxmail.com","commits":2}]},"readingTime":{"minutes":2.28,"words":685},"filePathRelative":"java/jpa/annotation-convert-in-jpa.md","localizedDate":"2024年3月10日","excerpt":"<p>日常开发中我们经常会遇到这样一种情况：有两个实体<code>图书Book</code>和<code>文件File</code>是多对多的关系，但是一般我们只关心与图书关联了多少文件而不关心文件关联了多少图书。所以通常我们在<code>Book</code>中用一个属性<code>file_ids</code>以<code>逗号分割</code>的方式存储多个<code>File</code>的id。</p>\\n<p>但是<code>File</code>的id是一个<code>Long</code>类型的<code>自增主键</code>，我们将<code>Book</code>对象查询出来后还要再对<code>file_ids</code>属性进行分割处理，处理完保存时又要进行逗号拼接，非常麻烦。有没有一个办法可以将这个繁琐的操作简化呢？<code>JPA</code>有一个注解<code>@javax.persistence.Convert</code>可以帮我们做这件事。</p>\\n","autoDesc":true}');export{r as comp,k as data};
